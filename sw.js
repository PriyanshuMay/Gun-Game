self.importScripts('/assets/js/data/swcache.js'); const cacheName = 'cp-20210916.0138'; const offlinePage = '/offline/'; function verifyDomain(url) { for (const domain of allowedDomains) { const regex = RegExp(`^http(s)?:\/\/${domain}\/`); if (regex.test(url)) { return true; } } return false; } function isExcluded(url) { for (const item of denyUrls) { if (url === item) { return true; } } return false; } // Delete caches that do not match the current version of the service worker. function clearOldCaches() { return caches.keys().then(keys => { return Promise.all( keys .filter(key => key.indexOf(offlineCache) !== 0) .map(key => caches.delete(key)) ); }); } // Precache specific pages function cacheOfflinePage() { return caches.open(offlineCache) .then(cache => { return cache.addAll([offlinePage, resource]); }) .catch(error => console.log(error)) } // Install the service worker self.addEventListener('install', event => { event.waitUntil( cacheOfflinePage() .then( () => self.skipWaiting() ) ); }); // Activate the service worker self.addEventListener('activate', event => { event.waitUntil( clearOldCaches() .then(() => self.clients.claim()) ); }); // Try and serve up cached page, or else show networked page, or else show offline page self.addEventListener('fetch', event => { let request = event.request; event.respondWith( caches.match(request) .then(response => { return response || fetch(request) .then( response => { // NETWORK if (event.request.method !== 'GET' || !verifyDomain(url) || isExcluded(url)) { return response; } if (response && response.ok) { let copy = response.clone(); caches.open(offlineCache) .then( cache => cache.put(request, copy) ); } return response; }) .catch( error => { // OFFLINE if (request.mode == 'navigate') { return caches.match(offlinePage); } }); }) ); });
